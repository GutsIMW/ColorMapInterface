"use strict";

/**
 * Class modelizing a channel (Model in the MVC Design Pattern)
 */
class Channel {
    #colorName; // RGB Symbol indicating the color that this channel models
    #checkpoints; // An array of checkpoint objects defining a BÃ©zier curve, the checkpoints are sorted by ascending X
    #discretizationNumber; // The number of point + 1 (sometimes +2 because float calulation isn't precise) that are discretized to represent the curve.
    #discretizedCurve; // An array of point discretized from the Bezier curve generated by the DeCasteljau algorithm
    
    /**
     * Channel constructor
     * @param  {Symbol} colorName - A RGB Symbol indicating the color that this channel models
     * @param  {Integer} discretizationNumber=1000 - The number of points to be discretized when evaluting the curve, its value should be chosen according to the accuracy requirements
     */
    constructor(colorName, discretizationNumber = 1000) {
        if(colorName != RGB.Red && colorName != RGB.Green && colorName != RGB.Blue) {
            throw "Invalid color name, must be an instance of RGB."
        }
        this.#colorName = colorName;
        this.#checkpoints = new Array(); // Initialize the checkpoints array
        
        // Define the default channel as being defined by two checkpoints at the minimum x value and at the maximum x value
        let firstCheckpoint = new Checkpoint(0, 1/2, this.#colorName); // The default channel is defined by a constant curve with y = 0.5
        let lastCheckpoint =  new Checkpoint(1, 1/2, this.#colorName);
        this.#checkpoints.push(firstCheckpoint);
        this.#checkpoints.push(lastCheckpoint);

        this.#discretizationNumber = discretizationNumber;
        this.discretizeCurve();// Discretize the default curve to be able to display it if needed
    }
    /**
     * @return {Symbol} - The color that this channel models
     */
    getColorName() {
        return this.#colorName;
    }
    
    /**
     * @return {Array<checkpoint>} - The array of checkpoints that defines the channel
     */
    getCheckpoints() {
        return this.#checkpoints;
    }
    
    /**
     * @return {Array<Point>} - The array of points discretized from the channel curve
     */
    getDiscretizedCurve() {
        return this.#discretizedCurve;
    }

    /**
     * Sort the checkpoints array by ascending x value
     */
    sortCheckpoint() {
        this.#checkpoints.sort(function(a, b) {
            return a.getX() - b.getX();
        });
    }

    /**
     * Add a checkpoint to the channel. The checkpoint is automatically inserted at the right index, no need to sort the array
     * @param  {Number} x - The x coordinate, in [0, 1]
     * @param  {Number} y - The y coordinate, in [0, 1]
     */
    addCheckpoint(x, y) {
        if(x === 0 || x === 1) { // The first and last chckpoint are already positionned in every case and can only be moved, not replaced
            return
        }
        if(x < 0 || x > 1 || y < 0 || y > 1) { // Must be normalized value, also 0 and 1 position is reserved to the first and last checkpoint
            throw "Invalid parameter, the parameters x and y must be normalized float, superior to 0 and inferior to 1.";
        }

        let checkpoint = new Checkpoint(x, y, this.#colorName);
        let i = 0;
        while(i < this.#checkpoints.length && this.#checkpoints[i].getX() < checkpoint.getX()) { // Determine the index where the new checkpoint should be inserted
            i++;
        }
        this.#checkpoints.splice(i, 0, checkpoint); // Inserts the new checkpoint
        this.discretizeCurve(); // Discretize the updated curve
    }
    /**
     * Remove a specified checkpoint from the channel
     * @param  {Checkpoint} checkpoint - The checkpoint to remove
     */
    removeCheckpoint(checkpoint) {
        let i = 0;
        for(i = 0; i < this.#checkpoints.length; i++) { // Determine the index of the checkpoint to remove
            if(this.#checkpoints[i] === checkpoint) { // Once the index of the checkpoint has been found
                this.#checkpoints.splice(i, 1); // Remove the checkpoint from this.#checkpoints array
                this.discretizeCurve(); // Discretize the updated curve
                return; // The checkpoint has been removed and the updated curve is discretized, the function can return
            }
        }
        if(i === this.#checkpoints.length) { // Then there is an error
            throw checkpoint + " is not in the array " + this.#checkpoints;
        }
    }

    /**
     * @param  {Checkpoint} checkpoint - The checkpoint that we want to know the index
     * @return {Integer} - The index of the checkpoint parameter, -1 if the specified checkpoint is not part of this channel
     */
    indexOfCheckpoint(checkpoint) {
        let i = 0;
        while(i < this.#checkpoints.length) {
            if(checkpoint === this.#checkpoints[i]) {
                return i;
            }
            i++
        }
        return -1; // Means that checkpoint is not in this.#checkpoints
    }

    /**
     * Move the specified checkpoint at (x,y) coordinates
     * @param  {Checkpoint} checkpoint - the checkpoint to move
     * @param  {Number} x - The x coordinate, in [0, 1]
     * @param  {Number} y - The y coordinate, in [0, 1]
     */
    moveCheckpoint(checkpoint, x, y) {
        if(this.indexOfCheckpoint(checkpoint) != 0 && this.indexOfCheckpoint(checkpoint) != this.#checkpoints.length - 1) { // Only move the checkpoint on the x-axis if it is not the first or last checkpoint
            checkpoint.setX(x); // Move on the x-axis
        }
        checkpoint.setY(y); // Move on the y-axis
        this.sortCheckpoint(); // Ensure that the checkpoints are sorted
        this.discretizeCurve(); // Discretize the updated curve
    }

    
    /**
     * @param  {Integer} i - The index of a checkpoint to return
     * @return {Checkpoint} - The checkpoint at index i
     */
    getCheckpointAtIndex(i) {
        return this.#checkpoints[i];
    }
    
    /**
     * Discretize the curve as an Open Uniform Qadratic B-Spline
     */
    discretizeCurve() {
        this.#discretizedCurve = BSplines.discretizeOpenQuadraticBSpline(this.#checkpoints, this.#discretizationNumber);
    }

    /**
     * Returns the two discretized points between which x is located
     * @param  {number} x - An x coordinate, in [0, 1]
     * @return {Array<Point>} - An array of two points
     */
    findNeighbors(x) {
        let i = 0
        while(i < this.#discretizedCurve.length && x >= this.#discretizedCurve[i].getX()) {
            i++;
        }
        if(i === this.#discretizedCurve.length) {
            return [this.#discretizedCurve[i-2], this.#discretizedCurve[i-1]];
        }
        return [this.#discretizedCurve[i - 1], this.#discretizedCurve[i]];
    }
    
    /**
     * Approximate the y value on the curve at x
     * @param  {Number} x - An x coordinate, in [0, 1]
     * @return {number} - A y coordinate, in [0, 1]
     */
    evaluateX(x) {
        let neighbors =  this.findNeighbors(x); // Find the two points around x
        let deltaDist = (x - neighbors[0].getX()) * (1/(neighbors[1].getX() - neighbors[0].getX())); // Parameter of the linear interpolation
        return neighbors[0].getY() * (1 - deltaDist) + neighbors[1].getY() * deltaDist; // Linear interpolation
    }

    /**
     * Redefined the channel as at its instantiation
     */
    clearChannel() {
        this.#checkpoints = new Array();
        let firstCheckpoint = new Checkpoint(0, 1/2, this.#colorName); // Initialize the channel as a constant curve with y = 0.5
        let lastCheckpoint =  new Checkpoint(1, 1/2, this.#colorName);
        this.#checkpoints.push(firstCheckpoint);
        this.#checkpoints.push(lastCheckpoint);
        this.discretizeCurve();
    }
}
